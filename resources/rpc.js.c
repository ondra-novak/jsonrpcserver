const char *jsonrpcserver_rpc_js="\n\n///Initializes RPC client\n/**\n * @param rpc_url - url of rpc server\n * @p"
"aram method_list - array of methods. This list can be retrieved linking the scri"
"pt \"RPC/methods/XXX.js\" where\n * @param options - optional object. Currently "
"only one option is available \"useMulticall\" which can be true or false. Defaul"
"t is true.\n *                   If useMulticall is true, then multiple requests"
" are packed into single \"Server.multicall\" call.  \n *                   If us"
"eMulticall is false, then multiple requests are no longer packed. They are sent "
"separatedly each for single request.\n *                   Note that object can "
"process one request at time, other requests are queued or combined into multical"
"l pack\n * XXX is name of variable that will contain list of methods\n *\n * Use"
" operator new to construct object. Object will map all methods to the object as "
"standard javascript methods\n */\nfunction RpcClient (rpc_url, method_list, opti"
"ons) {\n\n\tvar lastIdent = 0;\n\tvar connection = new XMLHttpRequest();\n\t\n\t"
"var requests = [];\n\tvar requests_promises = [];\n\t\n\t//initialize promise to"
" filled\n\tvar exchangePromise = new Promise(function(ok,fail) {\n\t\tok(true);\n"
"\t});\n\t\n\tvar useMulticall = true;\n\n\tvar url = rpc_url; //url rpc serveru\n"
"\t\n\tvar me = this;\n\n\tvar doCall = function(method, args) {\n\t\treturn new "
"Promise(function(ok,fail) {\n\t\t\n\t\t\tvar idle = requests.length == 0;\n\t\t\t"
"requests.push([method,args]);\n\t\t\trequests_promises.push([ok,fail]);\n\t\t\t\n"
"\t\t\tif (idle || !useMulticall) exchangePromise = exchangePromise.then(sheduleR"
"equest);\n\t\t});\n\t}\n\t\n\tvar getRequests = function() {\n\t\tif (useMultica"
"ll) {\n\t\t\tvar p = requests;\n\t\t\trequests = [];\n\t\t\treturn p;\n\t\t} els"
"e {\n\t\t\treturn [requests.shift()];\n\t\t}\n\t}\n\n\tvar getPromises = functio"
"n() {\n\t\tif (useMulticall) {\n\t\t\tvar p = requests_promises;\n\t\t\trequests"
"_promises = [];\n\t\t\treturn p;\n\t\t} else {\n\t\t\treturn [requests_promises."
"shift()];\n\t\t}\n\t}\n\n\tvar sheduleRequest = function(x) {\t\t\n\t\t\tvar r ="
" getRequests();\n\t\t\tvar rp = getPromises();\n\t\t\tif (r.length == 0) return "
"true;\n\t\t\telse if (r.length == 1) {\n\t\t\t\treturn new Promise(function(ok,f"
"ail) {\n\t\t\t\t\tdoCall2(r[0][0], r[0][1]).then(\n\t\t\t\t\t\t\tfunction(v) {\n"
"\t\t\t\t\t\t\t\trp[0][0](v);\n\t\t\t\t\t\t\t\tok(true);\n\t\t\t\t\t\t\t\treturn "
"v;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfunction(v) {\n\t\t\t\t\t\t\t\trp[0][1](v);\n"
"\t\t\t\t\t\t\t\tok(true);\n\t\t\t\t\t\t\t\treturn v;\n\t\t\t\t\t\t\t});\n\t\t\t\t"
"});\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new Promise(function(ok,fail) {\n\t\t"
"\t\t\tdoCall2(\"Server.multicall\",r).then(\n\t\t\t\t\t\tfunction(v) {\n\t\t\t\t"
"\t\t\t\n\t\t\t\t\t\t\tvar i;\n\t\t\t\t\t\t\tvar e = 0;\n\t\t\t\t\t\t\tfor (i = 0"
"; i < v.results.length; i++) {\n\t\t\t\t\t\t\t\tif (v.results[i] === null) {\n\t"
"\t\t\t\t\t\t\t\trp[i][1](v.errors[e++]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t"
"\t\t\trp[i][0](v.results[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t"
"\tok(true);\n\t\t\t\t\t\t\treturn v;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}, function(e)"
" {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar i;\n\t\t\t\t\t\t\tfor (i = 0; i < rp.lengt"
"h; i++) {\n\t\t\t\t\t\t\t\trp[i][1](e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tok(true)"
";\n\t\t\t\t\t\t\treturn e;\n\t\t\t\t\t\t});\n\t\t\t\t\n\t\t\t\t});\n\t\t}\t\t\t\t"
"\t\n\t\t\t\t\n\t}\n\t\t\n    var updateContext = function(c) {\n    \tvar change"
"d = false;\n\t\tfor (var i in c) {\n\t\t\tchanged = true;\n\t\t\tif (i == null) "
"delete me.context[i];\n\t\t\telse me.context[i] = c[i];\n\t\t}\n/*    \tif (chan"
"ged && localStorageKey != null) {\n    \t\tlocalStorage[localStorageKey] = JSON."
"stringify(this.context);\n    \t}*/\n    }\n\n\n\t\n\tvar doCall2 = function(met"
"hod,args) {\n\t\treturn new Promise(function(ok,fail) {\n\t\t\tvar request = {\n"
"\t\t\t\t\tid:lastIdent,\n\t\t\t\t\tmethod:method,\n\t\t\t\t\tparams:args,\n\t\t\t"
"\t\tcontext:me.context\n\t\t\t};\n\t\t\tlastIdent++;\n\t        var data = JSON."
"stringify(request);\n\t        connection.onreadystatechange =  function() {    "
"        \t\n\t            if (connection.readyState == 4  ) {\n\t               "
"      if (connection.status == 200) {\n\t                    \tvar response = co"
"nnection.responseText;\n\t                        var r = JSON.parse(response);\n"
"\t                        if (r.error) {\n\t                        \tfail(r.err"
"or);\n\t                        } else {\n\t\t\t\t    \t\t\tif (r.context) updat"
"eContext(r.context);\n\t                        \tok(r.result);\n\t             "
"           }\n\t                     } else {\n\t                         \n\t  "
"                  \t me.onConnectionError(connection.status,request,\n\t        "
"            \t\tfunction(e) {\n\t                    \t\t \tif (e.result) {\n\t "
"                   \t\t \t\tif (e.context) updateContext(e.context);\n\t    \t  "
"                      \tok(e.result);\n\t                    \t\t \t} else if (e"
".error) {\n\t                    \t\t \t\tfail(e.error);\n\t                    "
"\t\t \t} else if (e) {\n\t                    \t\t \t\tdoCall2(request.method,re"
"quest.params)\n\t                    \t\t \t\t\t.then(function(v) {ok(v);},funct"
"ion(v) {fail(v);});\n\t                    \t\t \t} else {\n\t                  "
"  \t\t \t\tfail(RpcClient.FAILED);\n\t                    \t\t \t}              "
"          \t\t   \n\t                    \t \t});\n\t                     }\n\t "
"           }\n\t        }\n\t        connection.open(\"POST\", url, true);\n\t  "
"      connection.setRequestHeader(\"Accept\",\"application/json\");\n\t        c"
"onnection.setRequestHeader(\"Content-Type\",\"application/json\");\n\t        co"
"nnection.send(data);\n\t\t});\n\n\t}\n\t\n\tvar regMethod = function(obj, locnam"
"e, remotename) {\n\t\tvar k = locname.indexOf('.');\n\t\tvar r = remotename;\n\t"
"\tif (k == -1) {\n\t\t\tobj[locname] = function() {    \t\t\t\t\n\t\t\t\tvar arg"
"s = new Array();    \t\t\t\t\n\t\t\t\tfor (var x =0; x < arguments.length;x++) {"
"\n\t\t\t\t\targs.push(arguments[x]);\n\t\t\t\t}\n\t\t\t    return doCall(r,args)"
";\n\t\t\t}\n\t\t} else {\n\t\t\tvar subloc = locname.substr(0,k);\n\t\t\tvar out"
"loc = locname.substr(k+1);\n\t\t\tif (!(subloc in obj)) obj[subloc] = new Object"
"();\n\t\t\tregMethod(obj[subloc],outloc,remotename);\n\t\t}    \t\t\n\t}\n\t\n\t"
"\n\tmethod_list.forEach(function(name) {\n\t\t\tregMethod(me,name,name);\n\t});\n"
"\n\tif (options) {\n\t\tif (options.hasOwnProperty(\"useMulticall\")) useMultica"
"ll = options.useMulticall;\n\t\tif (options.hasOwnProperty(\"onConnectionError\""
")) this.onConnectionError = options.onConnectionError;\n\t}\n\t\n\tthis.context "
"= new Object();\n\tthis.call = doCall;\n\t\n};\n\n///Default behaviour for http-"
"error. You can write own handler\n/**\n * @param status status code - read from "
"XMLHttpRequest()\n * @param request whole request object. \n * @param resolve ca"
"llback function to resolve this situation. If called with true, then request is "
"repeated.\n *   if called with false, then request is failed. If called with obj"
"ect, then object must be formatted as\n *   standard JSON response. This respons"
"e is then used to fullfil or reject apropriate promise on that request.\n *\n * "
"@note Note that for Server.multicall call, you should return apropriate response"
"\n * \n */\nRpcClient.prototype.onConnectionError = function(status,request,reso"
"lve) {\n\tif (status == 404) resolve(false);\n\telse resolve(confirm(\"Error \" "
"+ status + \" while processing request: \" + request.method +\". Retry?\"));\n}\n"
"\n\n///canceled multicall request\nRpcClient.CANCELED = \"canceled\";\nRpcClient"
".FAILED = \"failed\";\n\n///Extends promise - function store\n/** Stores result "
"to object under specified key once the promise is filled.  */\nPromise.prototype"
".store = function(obj,name) {\n\treturn this.then(function (v) {\n\t\tobj[name] "
"= v;\n\t\treturn v;\n\t});\n}\n\n///Extends promise - function log\n/** Dumps re"
"sult to console  */\nPromise.prototype.log = function() {\n\treturn this.then(fu"
"nction (v) {\n\t\tconsole.log(v)\n\t\treturn v;\n\t},function(e) {\n\t\tconsole."
"error(e)\n\t\treturn e;\t\t\n\t});\n}\n\n\n\n";
unsigned int jsonrpcserver_rpc_js_length=7219;
